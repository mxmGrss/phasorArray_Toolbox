function [Xhm,Xph] = Lyap_Harmonique(Ahm,Bhm,h,omeg,varargin)
%LYAP  Solve Harmonic Lyapunov equations.
%
%   Xhm = Lyap_Harmonique(Ahm,Qhm,h,omeg) solves the Harmonic Lyapunov matrix equation:
%
%       (Ahm-Nh)'*X + X*(Ahm-Nh) + Qhm = 0
%
%   Xhm = Lyap_Harmonique(Ahm,Bhm,Chm,h,omeg) solves the Harmonic Sylvester equation:
%
%       (Ahm-Nh)*X + X*(Bhm-Nh) + Chm = 0   
%
%   Xhm = Lyap_Harmonique(Ahm,Bhm,Rhm,Qhm,h,omeg) solves the Harmonic Riccati equation:
%
%       (Ahm-Nh)'*X + X*(Ahm-Nh) + X*Bhm*Rhm^-1*Bhm'*X + Qhm = 0
%
%   omeg define the pulsation in Nh = diag( jk omeg) |k|<=h   
%
%   Implement the algorithm presented in Riedinger,2022, "Solvingz
%   Iniftine-Dimensional Harmonic Lyapunov and Riccati equation"
%
%   Mhm is an acceptable harmonic Matrix iff Mhm is a bloc matrix and each bloc
%   of Mhm is Toeplitz. ie for M(t) in R^{pxq}, T-periodic
%
%           [m_11(t) m_12(t) ... m_1q(t)]
%   M(t) =  [m_22(t)                    ]
%           [                           ]
%           [m_p1(t)         ... m_pq(t)]
%
%           [T(m_11) T(m_12) ... T(m_1q)]
%   Mhm =   [T(m_22)                    ]
%           [                           ]
%           [T(m_p1)         ... T(m_pq)]
%
%   Where T(m_ij) is the toeplitz matrix associated with the STFT (short
%   time fourier transform ) of the T-periodic signal m_ij(t), on the basis
%   linked to the 1/T frequency, truncated to the -hth:hth harmonics. 
%
%   If m_ij(t) is real, T(m_ij) is hermitian.
%
%   Mhm matrices can be provided as 3D array of size n x m x p consisting
%   of the phasors of the n x m M(t) matrices stocked along the third
%   dimension. p must be odd, and Mhm(:,:,(end-1)/2) is the phasor of order
%   0, Mhm(:,:,(end-1)/2+k) is the kth phasor of M(t).
%
%   [Xhm,Xph] = Lyap_Harmonique(...) 
%   return the harmonic phasors Xph in Xhm as a 3D array where the matrix
%   phasors are stocked along the third dimension, ie : 
%
%       Xph(:,:,h+1+d) is the dth phasor of X(t) the time matrix associated
%       with the harmonic matrix  Xhm. 
%       Xph(i,j,:) is the vector of the pashors of x_ij(t)

narginchk(4,6)
ni = nargin;
if ni<6 %4 or 5 argument is lyapunov or sylvester equation, common resolution
    if ni<5 %Lyapunov ( A-N )* P + P ( A-N ) + Q = 0
       Q=Bhm;
       A=Mat2Toeplitz(Ahm,2*h);%forme toeplitz par bloc
       size(A)
       A = Mph2coefph(A,2*h+1); % forme blocs toeplitz
       nxa = size(Ahm(:,:,1),1);
       nxB=nxa;
       NhA = kron(eye(nxa), diag(1i*(-h:h)*omeg));
       size(NhA)

       AmN=(A-NhA)';
       B=A ;
    elseif ni<6  %Sylvester (A-N) X + X (B-N) + Q = 0
        % <=>colX =  -(idna kron (A-N) + idn o B')^-1 colQ
       Q = h;
       h = omeg; %Sylvester
       omeg = varargin{1}; %Sylvester
       
       A = Mat2Toeplitz(Ahm,2*h); % Block-Toeplitz form
       A = Mph2coefph(A,2*h+1); % Toeplitz Blocks form
       B = Mat2Toeplitz(Bhm,2*h);
       B = Mph2coefph(B,2*h+1);

       nxa = size(Ahm(:,:,1),1);
       NhA = kron(eye(nxa), diag(1i*(-h:h)*omeg));
       nxB = size(Bhm(:,:,1),1);
       
       
       AmN=(A-NhA);
       
    end
    

       hQ=(size(Q,3)-1)/2; %troncature order of provided Q
       if hQ < h 
           dQ=padarray(Q,[0 0 h-hQ],0,'both'); %pad Q with 0 phasor to match h truncatur
       elseif hQ > h 
           dQ= Q(:,:,hQ+(-h:h));
       else
           dQ=Q;
       end
       dQ;
       
       dQ=permute(dQ,[3,1,2]);
       colQ=squeeze(reshape(dQ,[],1,1));
    
       M=(kron(eye(nxa),AmN)+pr(B,eye(nxB),h));
        
       colX=-( M\colQ);

       dX=reshape(colX,[],nxa,nxa);
       Xph=permute(dX,[2,3,1]);
       Xhm=Mat2Toeplitz(Xph,h);

else
   Q= h;
   h = omeg; %Sylvester
   omeg = varargin{1}; %Sylvester
   Qhm= h;
   Rhm = varargin{1}; 
   h = varargin{2}; %Riccati
end

% lqr(a,b,q,r,)
end