function [A] = rand_phasor(nx,ny,h,arg)
%rand_phasor Produce a random 3D representing
%   Detailed explanation goes here
%random matrices


arguments
    nx
    ny
    h
    arg.time_structure='real'
end
A=zeros(nx,ny,2*h+1);


switch arg.structure
    case 'real'
        for hh=0:h
            A(:,:,h+1+hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2*(hh~=0)).*(rand(nx,ny)*8)*1/(hh+1)^2;
            A(:,:,h+1-hh)=conj(A(:,:,h+1+hh));
        end
    
    case 'symetric'
    for hh=0:h
         A(:,:,h+1+hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2*(hh~=0)).*(rand(nx,ny)*8)*1/(hh+1)^2;
         A(:,:,h+1+hh)=(A(:,:,h+1+hh)'+A(:,:,h+1+hh))/2;
         A(:,:,h+1-hh)=conj(A(:,:,h+1+hh));
    end

    case 'sdp'

    case 'hermitian'
        for hh=0:h
            A(:,:,h+1+hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2).*(rand(nx,ny)*8)*1/(hh+1)^2;
            A(:,:,h+1+hh)=(A(:,:,h+1+hh)'+A(:,:,h+1+hh))/2;
            A(:,:,h+1-hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2).*(rand(nx,ny)*8)*1/(hh+1)^2;
            A(:,:,h+1-hh)=(A(:,:,h+1-hh)'+A(:,:,h+1-hh))/2;
        end

    otherwise

        for hh=0:h
            A(:,:,h+1+hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2).*(rand(nx,ny)*2)*1/(hh+1)^2;
            A(:,:,h+1-hh)=((rand(nx,ny)-0.5)*2+1i*(rand(nx,ny)-0.5)*2).*(rand(nx,ny)*2)*1/(hh+1)^2;
        end

end

end