function [Kk, S] = RicHarmonicKlein(A, B, Q, R, K0, max_iter,htrunc)
%RIC_HARMONIC_KLEIN Iterative Riccati algorithm
%   A: System matrix
%   B: Input matrix
%   Q: State weighting matrix
%   R: Control weighting matrix
%   K0: Initial feedback gain
%   max_iter: Maximum number of iterations (optional)

arguments (Input)
    A
    B
    Q
    R
    K0
    max_iter = 100; % Default value for max_iter
    htrunc = []
end

if isempty(htrunc)
    htrunc = max(size(A, 3), size(B, 3), size(Q, 3), size(R, 3), size(K0, 3));
end


Ak0 = A - B * Kk{kk};


Rinv = inv(R);
htrunc = 20;
Kk{1} = K0;
S = cell(1, max_iter); % Preallocate S for max_iter iterations

for kk = 1:max_iter
    if kk > 1
        Kk{kk} = Rinv * B.' * S{kk-1};
    end
    Ak{kk} = A - B * Kk{kk};
    Yk{kk} = Kk{kk}.' * R * Kk{kk};
    
    % Solve Lyapunov: Akâ€™*S + S*Ak + (Yk+Q) + dot(S) = 0
    M = kron(eye(2), Ak{kk}.' ) + kron(Ak{kk}.' , eye(2));
    Ss = (-M * TB(htrunc) - NTB(M, htrunc, T)) \ (TF_TB(vec(Yk{kk} + Q), htrunc));
    SS = TF_TB_2_PhasorArray(Ss, 2, 2);
    S{kk} = SS;
    
    % Check convergence
    if kk > 1
        rel_change = norm(value(S{kk} - S{kk-1}), 'fro') / norm(value(S{kk}), 'fro');
        if rel_change < 1e-8
            fprintf('Converged at iteration %d\n', kk);
            break;
        end
    end
end

% Verify Riccati equation
riccati_residual = d(S{end}, T) + A.' * S{end} + S{end} * A - S{end} * B * Rinv * B.' * S{end} + Q;
fprintf('Riccati residual norm: %.2e\n', norm(value(riccati_residual), 'fro'));
end